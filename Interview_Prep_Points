Java OOPS Concept:
Java is an object oriented language widely used in web application,mobile and embedded system.

## JVM, JRE, JDK

JVM (Java Virtual Machine) - It is an abstract machine. It is called virtual machine because it doesn't exist physically. It is a specification that provides runtime environment in which java bytecode
	can be executed. Main tasks are :
		1. Loads code
		2. Verifies code
		3. Executed code
		4. Provides runtime env

JRE (Java Runtime Environment) - It is a set of software tools which are used for developing java applications. It is used to provide the runtime envs. It is the implmentation of JVM. It physically exists.

JDK (Java Development Kit) - JDK is a software development environment which is used to develop Java Applications and applets. It physically exists. It contains JRE + Standard tools.
		Ex - Standard Edition Java Platform. It contains JVM, a few other resources such as interpreter/loader(java), a complier(javac), an archive(jar), a document generator (javadoc)
		to complete the development of java application.

JVM, JRE and JDK , all are platform dependent because the configuration of each OS is different from each other.But Java is platform independent.

JVM + Set of libraries + Other files -> JRE + Development tools (java, javac) -> JDK 

Basic concepts of OOPS :
1. Object
2. Class
3. Polymorphism
4. Encapsulation
5. Abstraction
6. Inheritance

Difference between C++ and Java

1. C++ is platform dependent while Java is platform independent.
2. C++ is compiled language only but Java is both compiled as well as interpreted language.
3. C++ supports multiple inheritance but Java doesn't.
4. C++ supports structure and unions while Java doesn't.
5. C++ is nearer to hardware while Java  doesn't.

Method Overloading : When two functions are having same function names but different signatures, then, it is called method overloading. It is compile time polymorphism.The return
					 type can be same as well as different.

Method Overriding  : When two functions one in parent and one in child,having same method name, same signature and same return type, then, it is called method overriding.
					 It is Run time polymorphism.

Method Hiding : When two functions, one in parent and one in child, having same method name and signature but static, then it is called method hiding.

class Complex {
    public static void f1() {
        System.out.println(
                "f1 method of the Complex class is executed.");
    }

    public void f2()
    {
        System.out.println(
                "f2 method of the Complex class is executed.");
    }
}

class Sample extends Complex {
    public static void f1() {
        System.out.println(
                "f1 of the Sample class is executed.");
    }

    public void f2()
    {
        System.out.println(
                "f2 method of the Sample class is executed.");
    }
}

public class InterViewPrep {

    public static void main(String[] args) {
        Complex d1 = new Complex();
        Complex d2 = new Sample();

        // Static method should be called with class, not reference variable as it is misleading.
        // Even though we call using refernce variable, at compile time, class is only considered.
        // Method hiding
        d1.f1();
        d2.f1();

        // Method overriding
        d1.f2();
        d2.f2();
    }
}

Class : Class is a blueprint of an object, which signifies the data members and methods and that can be accessed via creating an instance of that class.It doesn't consume memory
		while creation.
Object: Object is an instance of an class, where each member variables and methods can be accessed by creating an object of that class.It consumes memory while creation.

Inheritance : When one object acquires all the properties and behaviour of another class or parent class, it is called inheritance.

Polymorphism : Polymorphism means many. So , it is the ability to show that the same thing can have different behaviours in different situations. Two types:
			   1. Compile Time Polymorphism : Method Overloading
			   2. Run Time Polymorphism : Method overriding
			   
Encapsulation : It may be defined as the protective shield that prevents the data from being accessed outside  the code. Acutally, variables are hidden and can be accessed through 
				setters and getters. It is also known as the combination of data hiding and abstraction because we are hiding the data by making the variables private and exposing 
				only setters and getters which are only required to access it, thus , exposing only essential information.
				Advantages :
				1. Data Hiding
				2. Increased Flexibility
				3. Reusability
				
Abstraction  : It is the property by virtue of which only essentials details are displayed to the user. It can be achieved with the help of abstract class and interfaces.
				Advantages :
				1. Reduces complexity to view the things
				2. Avoids code duplication and increases reusability.

Interface : An interface is a blueprint of a class.
			Variables are always public, static and final.
			Methods are always public and abstract.

Abstract Class and Interfaces :
1. Abstract class can have any access modifiers for members. Interfaces can have only one public members.
2. Abstract Class may or maynot contain abstract method. Interfaces can't have defined metehods.
3. Abstract Class can have static or non-static members. Interfaces can have only static member variables.
4. Abstract Class can have final or non-final members. Interfaces can have only final member variables.
			
Access Modifiers : how far the code can be accessed
1. private : can be accessed only inside the class body.
2. public  : can be accessed by everyone
3. protected : can be accessed by any class from same package and child class from other package
4. default  : can be accessed by any class from same package 

Instance Initialization Block : runs before constuctor, and value will be initialised every time the object is created and it will also run the same time
Static Initialization Block: It can access static memebers only.It will run only one time in the life time of a class.

Exception : Unwanted or unexpected event which occurs during the execution of a program.

Threading : Concurrent execution of multiple parts of program for maximum utilisation of CPU.
			It can be implemented with two ways.
			1. Extending the thread class. -> create a class extending Thread class and then just create instance of it
			2. Implementing the Runnable Interface. -> pass instance of class implementing the  interface in Thread class parameter
			
1. Extending Thread Class

// Java code for thread creation by extending
// the Thread class
class MultithreadingDemo extends Thread {
	public void run()
	{
		try {
			// Displaying the thread that is running
			System.out.println(
				"Thread " + Thread.currentThread().getId()
				+ " is running");
		}
		catch (Exception e) {
			// Throwing an exception
			System.out.println("Exception is caught");
		}
	}
}

// Main Class
public class Multithread {
	public static void main(String[] args)
	{
		int n = 8; // Number of threads
		for (int i = 0; i < n; i++) {
			MultithreadingDemo object
				= new MultithreadingDemo();
			object.start();
		}
	}
}

2. Implementing Runnable Interface

// Java code for thread creation by implementing
// the Runnable Interface
class MultithreadingDemo implements Runnable {
	public void run()
	{
		try {
			// Displaying the thread that is running
			System.out.println(
				"Thread " + Thread.currentThread().getId()
				+ " is running");
		}
		catch (Exception e) {
			// Throwing an exception
			System.out.println("Exception is caught");
		}
	}
}

// Main Class
class Multithread {
	public static void main(String[] args)
	{
		int n = 8; // Number of threads
		for (int i = 0; i < n; i++) {
			Thread object
				= new Thread(new MultithreadingDemo());
			object.start();
		}
	}
}

## Diamond Problem in Java
When the child class inherits the properites of more than one parent class and the name of the methods are same, then at runtime, the child gets confused which one method to call at runtime,
it is known as diamond problem in java. It can be fixed using interfaces.

Problem
// Java Program to demonstrate 
// Diamond Problem 
import java.io.*; 

// Parent Class1 
class Parent1 { 
	void fun() { System.out.println("Parent1"); } 
} 

// Parent Class2 
class Parent2 { 
	void fun() { System.out.println("Parent2"); } 
} 

// Inherting the Properties from 
// Both the classes 
class test extends Parent1, Parent2 { 
	// main function 
	public static void main(String[] args) 
	{ 
		test t = new test(); 
		t.fun(); 
	} 
}

Solution
// Java Programs to illustrate 
// use of Interface to solve 
// Diamond Problem 
import java.io.*; 

// Interfaces Declared 
interface Parent1 { 
	void fun(); 
} 

// Interfaces Declared 
interface Parent2 { 
	void fun(); 
} 

// Inheritance using Interfaces 
class test implements Parent1, Parent2 { 
	public void fun() 
	{ 
		System.out.println("fun function"); 
	} 
} 

// Driver Class 
class test1 { 
	// main function 
	public static void main(String[] args) 
	{ 
		test t = new test(); 
		t.fun(); 
	} 
}


File Handling in Java

Why File Handling is Required :-
File Handling is an integral part of any programming language as file handling enables us to store the output of any particular program in a file and allows us to perform certain operations on it.
In simple words, file handling means reading and writing data to a file.

Reading file and writing into file in java
The Java InputStream class is the superclass of all input streams. The input stream is used to read data from numerous input devices like the keyboard, network, etc. InputStream is an abstract class, and because of this, it is not useful by itself. 
However, its subclasses are used to read data. Ex - FileInputStream

The output stream is used to write data to numerous output devices like the monitor, file, etc. OutputStream is an abstract superclass that represents an output stream. OutputStream is an abstract class and because of this, it is not useful by itself. 
However, its subclasses are used to write data. Ex - FileOutputStream

File Operations In Java
1. Create File

In order to create a file in Java, you can use the createNewFile() method.
If the file is successfully created, it will return a Boolean value true and false if the file already exists.
// Import the File class
import java.io.File;

// Import the IOException class to handle errors
import java.io.IOException;

public class GFG {
	public static void main(String[] args)
	{

		try {
			File Obj = new File("myfile.txt");
			if (Obj.createNewFile()) {
				System.out.println("File created: "
								+ Obj.getName());
			}
			else {
				System.out.println("File already exists.");
			}
		}
		catch (IOException e) {
			System.out.println("An error has occurred.");
			e.printStackTrace();
		}
	}
}

2. Read from a file
We will use the Scanner class in order to read contents from a file. Following is a demonstration of how to read contents from a file in Java :

// Import the File class
import java.io.File;

// Import this class for handling errors
import java.io.FileNotFoundException; 

// Import the Scanner class to read content from text files
import java.util.Scanner; 

public class GFG {
	public static void main(String[] args)
	{
		try {
			File Obj = new File("myfile.txt");
			Scanner Reader = new Scanner(Obj);
			while (Reader.hasNextLine()) {
				String data = Reader.nextLine();
				System.out.println(data);
			}
			Reader.close();
		}
		catch (FileNotFoundException e) {
			System.out.println("An error has occurred.");
			e.printStackTrace();
		}
	}
}

3. Write to a file
We use the FileWriter class along with its write() method in order to write some text to the file. Following is a demonstration of how to write text to a file in Java :

// Import the FileWriter class
import java.io.FileWriter; 

// Import the IOException class for handling errors
import java.io.IOException; 

public class GFG {
	public static void main(String[] args)
	{
		try {
			FileWriter Writer
				= new FileWriter("myfile.txt");
			Writer.write(
				"Files in Java are seriously good!!");
			Writer.close();
			System.out.println("Successfully written.");
		}
		catch (IOException e) {
			System.out.println("An error has occurred.");
			e.printStackTrace();
		}
	}
}

4. Delete a file
We use the delete() method in order to delete a file. Following is a demonstration of how to delete a file in Java :

// Import the File class
import java.io.File; 

public class GFG {
	public static void main(String[] args)
	{
		File Obj = new File("myfile.txt");
		if (Obj.delete()) {
			System.out.println("The deleted file is : "
							+ Obj.getName());
		}
		else {
			System.out.println(
				"Failed in deleting the file.");
		}
	}
}

Garbage Collection in Java

1. In java , destruction of object is automatically done by JVM. There is no delete keyword in Java unlike C++.
2. When there is no reference to an object, then the object is assumed to be no longer needed and the memory occupied by the object is released.
3. This technique is called garbage collection and is accomplished by JVM.
4. Whenever you run a java program, JVM creates three threads
	* Main Thread : Responsible to call main function
	* Thread Scheduler : Responsible for thread scheduling
	* Garbage Collector Thread : Responsible for calling garbage collector, to sweep out abondoned objects from the heap memory.
5. In these three threads, main thread is a user thread and remaining two are daemon threads which run in background.
6. Abondoned objects or dead objects are those objects which doesn't have live references.
7. Garbage Collector thread before sweeping out an abondoned object, it calls finalize() method of an object
8. After finalize method is executed, object is destroyed from the memory.
9. We can garbage collector explicitly using System.gc() but it is just a request to a garbage collector not a command, so it is upto GC to honor this request.

Finlaize in Java

1. Exceptions occured in finalize method are not propagated. They are ignored by the garbage collector.
2. finalize() methods are not chained like constructors i.e there is no calling statement to superclass finalize() method inside the subclass of finalize() method.
   You need to explicitly call superclass finalize method.

class MyClass {
    private String name;

    MyClass(String name) {
        this.name = name;
        System.out.println("Object " + name + " is created.");
    }

    @Override
    protected void finalize() throws Throwable {
        try {
            System.out.println("Object " + name + " is being finalized.");
        } finally {
            super.finalize();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass obj1 = new MyClass("Test1");
        MyClass obj2 = new MyClass("Test2");

        obj1 = null; // Mark object for garbage collection
        obj2 = null; // Mark object for garbage collection

        // Request garbage collection (not guaranteed to run immediately)
        System.gc();

        // Add a delay to observe the finalization process (not recommended in production code)
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

// Output
Object Test1 is created.
Object Test2 is created.
Object Test1 is being finalized.
Object Test2 is being finalized.

Nested Classes in Java

There are basically two nested classes
1. Static Inner Class : It can access static members of outer class. We can directly create the object of inner class without creating object of outer class.
2. Non-static Inner Class : It can access non-static or instance member of outer class. We need to create the object of outer class and then inner class. It can have all the access modifiers

// Java Inner Class
// PURPOSE : The purpose of nested classes is to group classes that belong together, which makes your code more readable and maintainable.
class OuterClass_1 {
    int x = 10;

    class InnerClass_1 {
        int y = 5;
    }
}

// Private Inner Class
// PURPOSE : If we don't want outside objects to access the inner class, declare the class as private

class OuterClass_2 {
    int x = 10;

    private class InnerClass_2 {
        int y = 5;
    }
}

// Static Inner Class
class OuterClass_3 {
    int x = 10;

    static class InnerClass_3 {
        int y = 5;
    }
}

// Access Outer class from inner class
// Advantage : inner class can access attributes and methods of outer class

class OuterClass_4 {
    int x = 10;

    class InnerClass_4 {
        public int myInnerMethod() {
            return x;
        }
    }
}

class OuterClass_5 {

    static class InnerClass_5 {
        static void myInnerMethod() {
            System.out.println("Hey there!!");;
        }
    }
}

public class InterViewPrep {

    public static void main(String[] args) {
        // Inner Class
        OuterClass_1 myOuter = new OuterClass_1();
        OuterClass_1.InnerClass_1 myInner = myOuter.new InnerClass_1();
        System.out.println(myInner.y + myOuter.x);

        // Private inner class
        /*OuterClass_2 myOuter = new OuterClass_2();
        OuterClass_2.InnerClass_2 myInner = myOuter.new InnerClass_2();
        System.out.println(myInner.y + myOuter.x);*/

        OuterClass_3.InnerClass_3 myStaticInner = new OuterClass_3.InnerClass_3();
        System.out.println(myInner.y);

        OuterClass_4 myPublicOuter = new OuterClass_4();
        OuterClass_4.InnerClass_4 myPublicInner = myPublicOuter.new InnerClass_4();
        System.out.println(myPublicInner.myInnerMethod());

        OuterClass_5.InnerClass_5.myInnerMethod();

    }
}


Anonymous Classes In Java
Anonymous classes in java are more accurately known as anonymous inner classes. There is no such anonymous class without inner. They are defined inside another class.
Anonymous classes are inner classes with no name. It can have only those methods which are already available in parent class.
To instantiate anonymous inner class, we can do it by following ways : 
	* Extend a class
		new ParentClass(constructor args){methods declarations}
	* Implement an interface
		new InterfaceName(){methods implementation}

Anonymous Class Properties
	- It doesn't have any name
	- It is meant for single instantiation. It is instantiated at the point of declaration. They can't be instantiated multiple times or reused elsewhere in the code.
	- It can't have explicit constructors

Examples

// Implementation by Interface
interface Greeting {
    void sayHello();
}

public class Main {
    public static void main(String[] args) {
        Greeting greeting = new Greeting() {
            @Override
            public void sayHello() {
                System.out.println("Hello, World!");
            }
        };
        
        greeting.sayHello(); // Output: Hello, World!
    }
}

// Implementation by Class
class Animal {
    void makeSound() {
        System.out.println("Some generic sound");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Animal() {
            @Override
            void makeSound() {
                System.out.println("Bark");
            }
        };
        
        myDog.makeSound(); // Output: Bark
    }
}


Generic use of anonymous classes
In applications with a graphical interface, the most common use case of anonymous classes is to create various event listeners. For example, in the following snippet:

button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        ...
    }
}
Since Java 8, lambda expressions seem to be a more preferred way though.

Generic Classes In Java 

Java Generics was introduced to deal with type-safe objects. It makes the code stable.Java Generics methods and classes, enables programmer with a single method declaration, a set of related methods, a set of related types. 
Generics also provide compile-time type safety which allows programmers to catch invalid types at compile time. Generic means parameterized types.

Single Type Parameter
class Solution<T>
{
   T data;
   public static T getData(){
       return data;
   }
}

Multiple Type Parameter
public class Pair<K, V> {

    private K key;
    private V value;

    public Pair(K key, V value) {
    this.key = key;
    this.value = value;
    }

    public K getKey()    { return key; }
    public V getValue() { return value; }
}

Generic Method In Java
We can also write generic functions that can be called with different types of arguments based on the type of arguments passed to the generic method. The compiler handles each method.

// Java program to show working of user defined
// Generic functions

class Test {
	// A Generic method example
	static <T> void genericDisplay(T element)
	{
		System.out.println(element.getClass().getName()
						+ " = " + element);
	}

	// Driver method
	public static void main(String[] args)
	{
		// Calling generic method with Integer argument
		genericDisplay(11);

		// Calling generic method with String argument
		genericDisplay("GeeksForGeeks");

		// Calling generic method with double argument
		genericDisplay(1.0);
	}
}

A Java Cursor is an Iterator, that is used to iterate or traverse or retrieve a Collection or Stream object's elements one by one

In java, local variables can be blank but the instance variables always have default values. If reference variable does not contain anything, bydefault it contains null.
In java, it is possible to declare a 2d array with different lengths of each array.

int[][] jaggedArray = new int[3][];

// Initialize the sub-arrays with different lengths
jaggedArray[0] = new int[2]; // First row has 2 elements
jaggedArray[1] = new int[3]; // Second row has 3 elements
jaggedArray[2] = new int[4]; // Third row has 4 elements

If two or more strings have the same set of characters in the same sequence, then they share the same reference in the memory.
Implemeting multithreading with runnable class is much preferable as multiple inheritance is not possible in java and implementing multithreading gives the programmer an opputunity to extend a class.

Singleton Class : The primary purpose of a Single class is to restrict the limit of the number of object creation to only one. 
				  This often ensures that there is access control to resources, for example, socket or database connection.
				  
Defining singleton class :
1. Make a constructor private.
2. Write a static method that has the return type object of this singleton class. Here, the concept of Lazy initialization is used to write this static method.

** To instantiate a normal class, we use a java constructor. On the other hand, to instantiate a singleton class, we use the getInstance() method.

Memory Management
Heap Memory: Used for dynamic memory allocation. Stores objects and instance variables. Managed by the garbage collector.
Stack Memory: Used for method calls and local variables. Each thread has its own stack. Memory is managed through stack frames.

class Singleton {
    // Static variable reference of single_instance
    // of type Singleton
    private static Singleton single_instance = null;
  
    // Declaring a variable of type String
    public String s;
  
    // Constructor
    // Here we will be creating private constructor
    // restricted to this class itself
    private Singleton()
    {
        s = "Hello I am a string part of Singleton class";
    }
  
    // Static method
    // Static method to create instance of Singleton class
    public static Singleton getInstance()
    {
        if (single_instance == null)
            single_instance = new Singleton();
  
        return single_instance;
    }
}

Lazy Loading : Lazy loading is the practice of delaying load or initialization of resources or objects until they’re 
			   actually needed to improve performance and save system resources.
			   
Eager Loading : Eager loading initializes or loads a resource as soon as the code is executed. 

-----------------------------------------------------------------------------------------
Java 8

New Features :

1. Lambda Expression : One line function
2. Interfaces having default method : Default method implementation
3. Method References : Referencing function with their names
4. Functional interface : interface with one functional interface
5. Stream API : stream to facilitate pipeline processing
6. Date Time API : Improved date time api
7. Optional : To handle null values properly

** Default methods were introduced in Java 8 to have 'Backward Compatibility in case JDK modifies any interfaces. In case a new abstract method is added to the interface, all classes implementing the interface will break and will have to implement the new method. With default methods, 
there will not be any impact on the interface implementing classes. default methods can be overridden if needed in the implementation. 

1. Lambda Expression :

	private static void printAllNumbersInListFunctional(List<Integer> numbers) {
		
		numbers.stream() // Convert to Stream
				.filter(number -> number % 2 == 0) // Lamdba Expression
				//mapping - x -> x * x
				.map(number -> number * number)
				.forEach(System.out::println);// Method Reference
		}
		
	private static int addListFunctional(List<Integer> numbers) {
		//Stream of number -> One result value
		  //Combine them into one result => One Value
		  // 0 and FP02Functional::sum
		return numbers.stream()
				.parallel()
		  //.reduce(0, FP02Functional::sum);	
		  // .reduce(0, (x,y) -> x + y);
			.reduce(0, Integer::sum);
		}
		
	List<Integer> squaredNumbers =  mapAndCreateNewList(numbers, mappingFunction);
	
	private static List<Integer> mapAndCreateNewList(List<Integer> numbers,
			Function<Integer, Integer> mappingFunction) {
		return numbers.stream()
				.map(mappingFunction)
				.collect(Collectors.toList());
	}
		
2. Method References : 
	A method reference can be used to point the followinng three types of methods 
	1. Static methods
	2. Instance methods
	3. Constructor using new methods (TreeSet::new)

3. Functional Interface :
   As compareTo Functional
   
		Predicate<Integer> isEvenPredicate = (Integer x) -> x % 2 == 0;  // A boolean valued Function

		Function<Integer, Integer> squareFunction = x -> x * x;         //  Takes first type of argument and produces second type of argument
		
		Function<Integer, String> stringOutpuFunction = x -> x + " ";

		Consumer<Integer> sysoutConsumer = x -> System.out.println(x);  // Takes argument and return nothing

		BinaryOperator<Integer> sumBinaryOperator = (x, y) -> x + y;   // Take two values and compute it
		
		//No input > Return Something
		Supplier<Integer> randomIntegerSupplier = () -> {
			Random random = new Random();
			return random.nextInt(1000);
		};
		
		//System.out.println(randomIntegerSupplier.get());
		
		UnaryOperator<Integer> unaryOperator = x -> 3 * x;         // 

4. Default Method :
   It is used for backward compatibility so that old interfaces can be used to leverage the lambda function
   Ex : forEach()
   
   
-------------------------------------------------------------------------------------------------------

SQL

DDL : create, alter, drop
DML : update, insert,delete
TCL  : grant revoke

--------------------------------------------------------------------------------------------------------
Container Concepts

Container Orchestration 
Container orchestration tools help manage the lifecycle of containerized applications, including deployment, scaling, and networking.
Some of the popular orchestration tools include :
1. Kubernetes
2. Docker Swarm
3. Amazon ECS
4. Google Kubernetes Engine
5. Microsoft Azure Kubernetes Engine
6. Amazon Kubernetes Service.

Responsibility of Container Orchestration tool :

1. Orchestration     : It allows you to manage a cluster of containers as a single virtual system. It provides feature for deploying, scaling and managing containerized application across multiple nodes.
2. Scalability       : It enables horizontal scaling of containers by adding or removing nodes from the cluster. It handles load balancing and service discovery to ensure efficient utilisation of resources.
3. High Availability : It ensures features for high availability, such as automatic failover and rescheduling of containers in case of node failures.
4. Production Ready  : It is designed for production use and is suitable for deploying and managing containerized applications in a distributed env.

--------------------------------------------------------------------------------------------------------
Spring Boot : Spring Framework + Embedded HTTP Servers - XML configuration
Actuator : It actually provides additional features which help us monitor the spring boot application. Specially useful for production

Advantages of Spring Boot over Spring :
1. Starter POM
2. Auto Configuration
3. Component Scanning
4. Embedded Server
5. InMemoryDB
6. Actuators

@SpringBootApplication is a combination of three annotations.
@Configuration - Signifies it is a configuration class
@EnableAutoConfiguration - It enables spring boot to autoconfigure application context. It creates the beans of objects based on the beans defined by us in configuration file or defined in classpath.
@ComponentScan - It scans the packages and configures the application.

XSD: XML Schema Definition

If an XML follows XSD, it is said to be valid XML.

Element is used to store some values in xml.
Complex Type is sort of class. It actually stores elements and attributes.
SimpleType is used to apply restrictions on elements
   
------------------------------------------------------------------------------------------------------

Interview Questions :

 *******  SOAP :  *******

1. What is the major obstacle users faced when using SOAP?

When using SOAP, users often see the firewall security mechanism as the biggest obstacle. This block all the ports leaving few like HTTP port 80 and the 
HTTP port used by SOAP that bypasses the firewall. The technical complaint against SOAP is that it mixes the specification for message transport with the 
specification for message structure.


 *******  REST (Representation State Transfer) :  *******

1. What is the concept of statelessness in REST?

The REST architecture is designed in such a way that the client state is not maintained on the server. This is known as statelessness. 
The context is provided by the client to the server using which the server processes the client’s request. The session on the server is identified by the 
session identifier sent by the client.

2. Can you tell the disadvantages of RESTful web services?

The disadvantages are:
1. As the services follow the idea of statelessness, it is not possible to maintain sessions. 
(Session simulation responsibility lies on the client-side to pass the session id)

2. REST does not impose security restrictions inherently. It inherits the security measures of the protocols implementing it. Hence, 
care must be chosen to implement security measures like integrating SSL/TLS based authentications, etc

** Representational State Transfer refers to transferring "representations". You are using a "representation" of a resource to transfer resource state which 
   lives on the server into application state on the client.

3. What are Idempotent methods? How is it relevant in RESTful web services domain?

The meaning of idempotent is that even after calling a single request multiple times, the outcome of the request should be the same. 
While designing REST APIs, we need to keep in mind to develop idempotent APIs. This is because the consumers can write client-side code which can result in 
duplicate requests intentionally or not. Hence, fault-tolerant APIs need to be designed so that they do not result in erroneous responses.

** REST provides idempotent methods automatically. GET, PUT, DELETE, HEAD, OPTIONS, and TRACE are the idempotent HTTP methods. POST is not idempotent.
** POST is not idempotent because POST APIs are usually used for creating a new resource on the server. While calling POST methods N times, there will be N new resources. 
   This does not result in the same outcome at a time.
   
4. What makes REST services to be easily scalable?

REST services follow the concept of statelessness which essentially means no storing of any data across the requests on the server. This makes it easier 
to scale horizontally because the servers need not communicate much with each other while serving requests.

5. Based on what factors, you can decide which type of web services you need to use - SOAP or REST?

* Does the client require a formal strict contract?
	If yes, SOAP provides strict contracts by using WSDL. Hence, SOAP is preferred here.

* Does your service require support for multiple formats of data?
	If yes, REST supports multiple data formats which is why it is preferred in this case.

* Does your service require both synchronous and asynchronous requests?
	SOAP has support for both sync/async operations.
	REST only supports synchronous calls.
	
* Does your service require statelessness?
	If yes, REST is suitable. If no, SOAP is preferred.

* Does your service require a high-security level?
	If yes, SOAP is preferred. REST inherits the security property based on the underlying implementation of the protocol. Hence, it can’t be preferred at all times.

* Does your service require support for transactions?
	If yes, SOAP is preferred as it is good in providing advanced support for transaction management.
	
 ******* Spring Boot :  *******
 
1. Why Spring Boot over Spring ?

 1. Starter POM.
 2. Auto Configuration.
 3. Embedded server.
 4. InMemory DB.
 5. Actuators

2. What does the @SpringBootApplication annotation do internally?

The @SpringBootApplication annotation is equivalent to using @Configuration, @EnableAutoConfiguration, and @ComponentScan with their default attributes.

@Configuration annotation indicates that a class declares one or more @Bean methods and may be processed by the Spring container to generate bean definitions 
and service requests for those beans at runtime.

The @EnableAutoConfiguration annotation enables Spring Boot to auto-configure the application context. Therefore, it automatically creates and 
registers beans based on both the included jar files in the classpath and the beans defined by us.

 ******* Microservices : *******

1. Main features of microservices 

 1. Decoupling
 2. Componentization
 3. Continuous Delivery
 4. Agility
 
2. Main components of microservices

 1. Containers, Clustering, and Orchestration
 2. Cloud Infrastructure 
 3. API Gateway
 4. Service Delivery
 
** Monolithic : Single Unit
** SOA        : Coarse Grained
** Microservice : Fine Grained

** Coupling: It is defined as a relationship between software modules A and B, and how much one module depends or interacts with another one. 
   Couplings fall into three major categories. Modules can be highly coupled (highly dependent), loosely coupled, and uncoupled from each other.

** Cohesion : It is defined as a relationship between two or more parts/elements of a module that serves the same purpose. Generally, a module with high cohesion 
   can perform a specific function efficiently without needing communication with any other modules. High cohesion enhances the functionality of the module.
   
 ******* Spring Cloud : *******
 
1. What is Spring Cloud ?

It may be defined as the Spring Boot based spring integration applications that provide integration with external system.

Advantages :

1. It overcomes issues associated with distributed system like network issues, latency, bandwidth issues and security issues.
2. Service Discovery : How services in a cluster can find and talk to each other. ( Eureka Service Registration and Discovery)
3. Load Balancing improves the distribution of load on services. (Netflix Ribbon)
4. Fault Tolerance : Hystrix Fault Tolerance 
				Suppose if the microservice in the above diagram failed, then using the traditional approach we will propagate an exception. But this will still cause the whole system to crash anyways.
				This problem gets more complex as the number of microservices increase. The number of microservices can be as high as 1000. This is where hystrix comes into picture
				We will be the Fallback method feature of Hystrix for this scenario.
5. Circuit Breaker :  Hystrix Circuit Breaker
				If the exceptions keep on occuring in the firstPage method() then the Hystrix circuit will break and the employee consumer will skip the firtsPage 
				method all together and directly call the fallback method.

Cross-origin resource sharing (CORS) is a browser mechanism which enables controlled access to resources located outside of a given domain.

Angular Questions :

angular.json -> main.ts (entrypoint) -> it calls bootstrapm module (App Module)-> AppModule -> AppComponent


JAR & WAR

1. The first difference is in their extension.
2. JAR allows us to package multiple files in order to use it as library. WAR is used for web applications.
3. JAR can be executed with the command line but we need server to execute WAR.

spring profile ?

--------------------------------------------------------------------------------------------------------------
TweetApp Points

* We need to subscribe while calling http endpoints because HTTP calls in angular are asynchronous in nature. By default, it returns Observable in nature.




 




